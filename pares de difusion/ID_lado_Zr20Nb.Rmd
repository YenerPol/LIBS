---
title: "ID_lado_Zr20Nb"
author: "Paul Gomez"
date: "12/20/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Coeficiente de ID Er (Datos Lado Zr20Nb)

Acá se calcula el coeficiente de interdifiusion con los datos tomados desde la interfaz hacia el lado Zr20Nb

```{r Datos lado Zr20Nb, message=FALSE}
library(tidyverse, verbose = FALSE)
dir <- "./espectros/Lado Zr-20Nb/"

n_spec <- length(list.files(dir)) - 1

# Funcion para lectura de datos
FUN.read <- function(path, n){
        M <- numeric()
        for(i in 1:n){
                spec <- read_tsv(file = paste(path, "a",i,".ols",  sep = ''), 
                                 skip = 6, show_col_types = FALSE) %>% 
                        select(Counts)
                M <- rbind(M, spec$Counts) 
        }
        M
}

M_espectros <- FUN.read(dir, n_spec)
M_espectros <-  M_espectros %>% round(4) 
M_espectros %>% dim()

wavelen <- read_tsv(file = paste(dir, '/a1.ols', sep = ''), skip = 6,
                    show_col_types = FALSE) %>% 
           select(Wavelength) %>% rowid_to_column()

wavelen$Wavelength <- round(wavelen$Wavelength, 4)
```

## Normalizar por suma total

```{r Normalizar por suma total}
num_detec <- 4    # Numero de detectores
index_detec <- list(c(1:2048), c(2049:3983), c(3984:5924), c(5925:7865)) 

FUN.norm <- function(M, n = 4, index){
        lista <- vector(mode = 'list', length = n)
        for(i in 1:n){
                # separar detector
                lista[[i]] <- M[,index[[i]]]
                # hacer minimo = 0
                minimo <- apply(lista[[i]], 1, min)
                lista[[i]] <- lista[[i]] + abs(minimo)
                # Dividir por suma total
                total <- apply(lista[[i]], 1, sum)
                lista[[i]] <- lista[[i]] / total
        }
        lista       
}

M_norm <- FUN.norm(M_espectros, n = num_detec, index = index_detec)
M_norm <- cbind(M_norm[[1]],M_norm[[2]],M_norm[[3]],M_norm[[4]])
```

## Perfil de concentración

```{r}
FUN.cuentas <- function(p){
        ind <- wavelen$rowid[which(wavelen$Wavelength == p)]
        m <- M_norm[,(ind-2):(ind+2)]
        cuentas <- apply(m, 1, sum)
        cuentas
}

pico_Nb <- 322.3791
pico_Zr <- 357.0441
pico_Er <- 369.0904

Er <- FUN.cuentas(pico_Er)
Zr <- FUN.cuentas(pico_Zr)
Nb <- FUN.cuentas(pico_Nb)
```

```{r}
g <- data.frame(Er = Er, Zr = Zr, Nb = Nb) %>% 
        rowid_to_column() %>% 
        mutate(distancia = rowid*40) %>% 
        pivot_longer(Er:Nb,
                     names_to = "Elementos",
                     values_to = "Intensidad") %>% 
        ggplot(aes(x = distancia, y = Intensidad, colour = Elementos)) +
        geom_point() + geom_line() +
        labs(x = 'Distancia (um)')

caption <- paste("Lineas elegidas:","\n",
                 "Er: ",pico_Er,"\n", 
                 "Zr: ",pico_Zr,"\n", 
                 "Nb: ",pico_Nb,"\n", sep = '')

g + annotate(geom = 'text', x = 3003, y = 0.01, label = caption) + 
        ggtitle('Perfil lado: Zr20Nb')

g %>% plotly::ggplotly()
```

## Calculo de Coeficiente de ID

```{r}
df <- data.frame(cuentas = Er) %>% 
    rowid_to_column() %>% 
    mutate(distancia = rowid*40)
    
FUN.perfil <- function(element){
    # element: vector
    element %>% 
        ggplot(aes(x = distancia, y = cuentas)) +
        geom_point() +
        labs(x = 'Distancia (um)', y = 'Intensidad') +
        theme_classic()
}

FUN.perfil(df) %>% plotly::ggplotly()
```

```{r modelo lineal}
df_Er <- df %>% 
    filter(distancia >= 600 & distancia <=3500) %>% 
    select(cuentas) %>% 
    rowid_to_column() %>% 
    mutate(distancia = rowid*40)

FUN.perfil(df_Er) %>% plotly::ggplotly()

```

```{r}
erfcinv <- function(y) {
    y[y < 0 | y > 2] <- NA
    -qnorm(y/2)/sqrt(2)
}

FUN.0intercept <- function(DF, n){
    DF <- DF %>% mutate(erfc_inv = erfcinv(cuentas/n)) 
    fit <- lm(erfc_inv ~ distancia, DF)
    fit$coefficients[[1]]
}

iter <- 1
inter <- 1
paso <- 0.00001
v_int <- numeric()

while(inter > 10^-4){
    if(iter == 1){
        n_max <- max(df_Er$cuentas)
        inter <- FUN.0intercept(df_Er, n_max)
    }else{
        n_max <- n_max - paso
        inter <- FUN.0intercept(df_Er, n_max)
    }
    iter <- iter + 1
    v_int <- c(v_int, inter)
    #if(iter >= 1000) break
}

#plot(v_int)

g3 <- df_Er %>% 
    mutate(erfc_inv = erfcinv(cuentas/n_max)) %>% 
    ggplot(aes(x = distancia, y = erfc_inv)) +
    geom_point() +
    geom_smooth(method = 'lm') +
    labs(x = 'Distancia (um)', y = 'Erf_Inv(Intensidad)') +
    theme_classic()

g3 %>% plotly::ggplotly()
```

```{r}
fit <- lm(erfc_inv ~ distancia, df_Er %>% mutate(erfc_inv = erfcinv(cuentas/n_max)))
fit

D <- (10^-12)/(4*1.7021*10^7*(fit$coefficients[[2]])^2)
D
```

```{r}
write_delim(df_Er, file = './outputs/dataZr20Nb.txt', delim = " ", col_names = FALSE)
```

