---
title: "ID_diagonales"
author: "Paul Gomez"
date: "12/29/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Lectura de datos

```{r datos}
library(tidyverse, verbose = FALSE)

FUN.read <- function(path, n){
        M <- numeric()
        for(i in 1:n){
                spec <- read_tsv(file = paste(path, "a",i,".ols",  sep = ''), 
                                 skip = 6, show_col_types = FALSE) %>% 
                        select(Counts)
                M <- rbind(M, spec$Counts) 
        }
        M
}

M_espectros <- vector(mode = 'list', length = 2)

dir <- "./espectros/diagonal/ExpI/"
n_spec <- length(list.files(dir))
M_espectros[[1]] <- FUN.read(dir, n_spec)

dir <- "./espectros/diagonal/ExpII/"
n_spec <- length(list.files(dir))
M_espectros[[2]] <- FUN.read(dir, n_spec)

# cantidad de archivos por barrido
lapply(M_espectros, dim)

# wavelength values
wavelen <- read_tsv(file = paste(dir, '/a1.ols', sep = ''), skip = 6, show_col_types = FALSE) %>% 
                select(Wavelength) %>% 
                rowid_to_column()

wavelen$Wavelength <- round(wavelen$Wavelength, 4)

```

## Normalizacion

```{r}
# La normalizacion es por detector y se realiza por suma total. Los indices 
# correspondientes a cada detector son:
#         
#       - 1:2048
#       - 2049:3983
#       - 3984:5924
#       - 5925:7865

# Funcion de normalizacion
FUN.norm <- function(M, n = 4, index){
        lista <- vector(mode = 'list', length = n)
        for(i in 1:n){
                # separar detector
                lista[[i]] <- M[,index[[i]]]
                # hacer minimo = 0
                minimo <- apply(lista[[i]], 1, min)
                lista[[i]] <- lista[[i]] + abs(minimo)
                # Dividir por suma total
                total <- apply(lista[[i]], 1, sum)
                lista[[i]] <- lista[[i]] / total
        }
        lista       
}

num_detec <- 4    # Numero de detectores
index_detec <- list(c(1:2048), c(2049:3983), c(3984:5924), c(5925:7865)) 

M_norm <- M_espectros %>% map(FUN.norm, n = num_detec, index = index_detec)

# suma el el espectro que fue separado para normalizar por detector
M_norm <- M_norm %>% map(~ cbind(.x[[1]], .x[[2]], .x[[3]], .x[[4]]))

lapply(M_norm, dim) # para inspeccion
```

```{r}
# Funcion que integra el pico
FUN.cuentas <- function(p, barrido, spec_ini = 1, spec_fin = 200){
        ind <- wavelen$rowid[which(wavelen$Wavelength == p)]
        m <- M_norm[[barrido]][spec_ini:spec_fin,(ind-2):(ind+2)]
        cuentas <- apply(m, 1, sum)
        cuentas
}

# Funcion para graficar perfil
# 
FUN.perfil <- function(df){
        g <- df %>% 
                pivot_longer(Er:Nb,
                             names_to = "Elementos",
                             values_to = "Intensidad") %>% 
                ggplot(aes(x = rowid*40*cos(45), 
                           y = Intensidad, 
                           colour = Elementos)) +
                geom_point() #+ geom_line()
        
        caption <- paste("Lineas elegidas:","\n",
                         "Er: ",pico_Er,"\n", 
                         "Zr: ",pico_Zr,"\n", 
                         "Nb: ",pico_Nb,"\n", sep = '')
        
        g + annotate(geom = 'text', x = 20, y = 0.009, label = caption) +
                xlab('Distancia (micrones)') +
                ylab('Cantidad de cuentas (UA)')
}

pico_Er <- 369.0904
pico_Nb <- 322.3791
pico_Zr <- 357.0441
```
